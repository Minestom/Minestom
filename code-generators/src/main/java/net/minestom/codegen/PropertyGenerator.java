package net.minestom.codegen;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.palantir.javapoet.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.lang.model.element.Modifier;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public record PropertyGenerator(InputStream blocksFile, Path outputFolder) implements MinestomCodeGenerator {
    private static final String packageName = "net.minestom.server.instance.block.property";
    private static final String enumsPackageName = packageName + ".enums";

    private static final Map<Set<String>, String> MULTI_PROPERTY_ENUM_NAMES = Map.of(
            Set.of("north", "east", "south", "west"), "side"
    );

    @Override
    public void generate() {
        ensureDirectory(outputFolder);

        // collect properties
        final Properties properties = new Properties();
        final JsonObject json = GSON.fromJson(new InputStreamReader(blocksFile), JsonObject.class);
        json.entrySet().forEach((entry) -> {
            final JsonElement propertiesElement = entry.getValue().getAsJsonObject().get("properties");
            if (propertiesElement == null) return; // block doesn't have properties
            // ignore the namespace
            final String simpleBlockIdentifier = entry.getKey().substring(entry.getKey().indexOf(':') + 1);
            final JsonObject blockProperties = propertiesElement.getAsJsonObject();
            properties.registerProperties(new Identifier(simpleBlockIdentifier), blockProperties);
        });

        final ClassName implCN = ClassName.get(packageName, "Property");
        final ClassName generatedCN = ClassName.get(packageName, "Properties");
        final TypeSpec.Builder builder = TypeSpec.interfaceBuilder(generatedCN)
                .addModifiers(Modifier.SEALED)
                .addPermittedSubclass(implCN)
                .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
                        // ignore DataFlowIssue, IDEA thinks that T::typedValueOf shouldn't return null.
                        .addMember("value", "{\"unused\", \"DataFlowIssue\"}").build())
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName());

        final Set<Identifier> usedIdentifiers = new HashSet<>();

        // write boolean properties
        final ClassName booleanPropertyImplCN = ClassName.get(packageName, "BooleanProperty");
        final ParameterizedTypeName booleanProperty = ParameterizedTypeName.get(implCN, TypeName.get(Boolean.class));
        properties.properties.remove(List.of("true", "false")).properties.forEach((name, property) -> {
            final Identifier fieldIdentifier = property.getIdentifier();
            usedIdentifiers.add(fieldIdentifier);
            builder.addField(FieldSpec
                    .builder(booleanProperty, fieldIdentifier.constantName())
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer("new $T($S)", booleanPropertyImplCN, name).build());
        });
        // write integer properties
        final ClassName integerPropertyImplCN = ClassName.get(packageName, "IntegerProperty");
        final ParameterizedTypeName integerProperty = ParameterizedTypeName.get(implCN, TypeName.get(Integer.class));
        final Map<String, Property> integerProperties = new LinkedHashMap<>();
        properties.properties.entrySet().removeIf(entry -> {
            if (entry.getValue().type() != 1) return false; // not integer property
            entry.getValue().properties.forEach((name, property) ->
                    integerProperties.computeIfAbsent(name, Property::new).registerBlocks(property.blocks));
            return true;
        });
        integerProperties.forEach((name, property) -> {
            Identifier fieldIdentifier = property.getIdentifier();
            if (!usedIdentifiers.add(fieldIdentifier)) {
                fieldIdentifier = fieldIdentifier.withPrefix(new String[]{"int"});
                if (!usedIdentifiers.add(fieldIdentifier)) {
                    throw new RuntimeException("name collision for '" + name + "'");
                }
            }
            builder.addField(FieldSpec
                    .builder(integerProperty, property.getIdentifier().constantName())
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer("new $T($S)", integerPropertyImplCN, name).build());
        });

        properties.cleanEnums();
        writeEnumProperties(properties, usedIdentifiers, builder, implCN);
        writeFiles(JavaFile.builder(packageName, builder.build()).indent("    ").build());
    }

    private void writeEnumProperties(
            Properties properties,
            Set<Identifier> usedIdentifiers,
            TypeSpec.Builder builder,
            ClassName implCN
    ) {
        final NameAllocator<PropertyValues> propertyEnums = new NameAllocator<>();
        final NameAllocator<NamedProperty> propertyFields = new NameAllocator<>();
        properties.properties.values().stream().flatMap(
                propertyValues -> propertyValues.split == null ?
                        Stream.of(propertyValues) : Stream.concat(Stream.of(propertyValues), propertyValues.split.stream())
        ).forEach(propertyValues -> {
            propertyValues.properties.values().forEach(property -> {
                final Identifier propertyIdentifier = property.getIdentifier();
                final NamedProperty namedProperty = new NamedProperty(propertyValues, property, false);
                if (usedIdentifiers.contains(propertyIdentifier)) {
                    propertyFields.allocateName(
                            propertyIdentifier.withPrefix(namedProperty.prefix()),
                            namedProperty.prefixedValue());
                } else {
                    propertyFields.allocateName(propertyIdentifier, namedProperty);
                }
            });
            final Identifier enumName = propertyValues.getIdentifier();
            propertyEnums.allocateName(enumName, propertyValues);
        });

        // write enum properties and property enums
        propertyEnums.names.forEach((identifier, propertyEnum) ->
                writeFiles(JavaFile.builder(enumsPackageName, generateEnum(propertyEnum, identifier)).indent("    ").build()));
        final ClassName enumPropertyImpl = ClassName.get(packageName, "EnumProperty");
        propertyFields.names.forEach((identifier, namedProperty) -> {
            final ClassName currentEnum = ClassName.get(enumsPackageName,
                    namedProperty.values.getIdentifier().enumName());
            builder.addField(FieldSpec
                .builder(ParameterizedTypeName.get(implCN, currentEnum), identifier.constantName())
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                .initializer(
                        "new $T<>($S, $T::typedValueOf)",
                        enumPropertyImpl, namedProperty.property.name, currentEnum)
                .build()).build();
        });
    }

    private TypeSpec generateEnum(PropertyValues propertyValues, Identifier identifier) {
        final ClassName enumCN = ClassName.get(enumsPackageName, identifier.enumName());
        final TypeSpec.Builder enumBuilder = TypeSpec
                .enumBuilder(enumCN)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(ClassName.get(packageName, "PropertyEnum"))
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName());

        final CodeBlock.Builder fromPropStringSwitch = CodeBlock.builder()
                .beginControlFlow("return switch (value)");
        final CodeBlock.Builder toPropStringSwitch = CodeBlock.builder()
                .beginControlFlow("return switch (this)");

        for (final String propertyValue : propertyValues.values) {
            final String enumValue = propertyValue.toUpperCase(Locale.US);
            enumBuilder.addEnumConstant(enumValue);
            fromPropStringSwitch.add("case $S -> $L;\n", propertyValue, enumValue);
            toPropStringSwitch.add("case $L -> $S;\n", enumValue, propertyValue);
        }
        fromPropStringSwitch.add("default -> null;\n");

        final MethodSpec.Builder typedValueOf = MethodSpec.methodBuilder("typedValueOf")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .addAnnotation(Nullable.class)
                .addParameter(ParameterSpec.builder(String.class, "value").build())
                .returns(enumCN).addCode(fromPropStringSwitch.unindent().add("};").build());
        final MethodSpec.Builder untypedValue = MethodSpec.methodBuilder("untypedValue")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class).addAnnotation(NotNull.class)
                .returns(String.class).addCode(toPropStringSwitch.unindent().add("};").build());
        final MethodSpec.Builder property = MethodSpec.methodBuilder("property")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .returns(String.class);
        if (propertyValues.properties.size() == 1) {
            property.addCode("return $S;", propertyValues.properties.keySet().iterator().next())
                    .addAnnotation(NotNull.class);
        } else {
            property.addCode("return null;")
                    .addAnnotation(Nullable.class);
        }

        enumBuilder.addMethod(property.build()).addMethod(untypedValue.build())
                .addMethod(typedValueOf.build());

        return enumBuilder.build();
    }

    private static class NameAllocator<T extends NameAllocator.Prefixable<T>> {
        private final Map<Identifier, T> names = new LinkedHashMap<>();

        void allocateName(Identifier name, T value) {
            final T previousValue = names.put(name, value);
            if (previousValue == null) return;
            names.remove(name);
            final boolean aPrefix = value.canPrefix();
            final boolean bPrefix = previousValue.canPrefix();
            if (!(aPrefix || bPrefix)) {
                throw new RuntimeException("name collision for '" + String.join("_", name.words) + "'");
            }
            allocateName(aPrefix ? name.withPrefix(value.prefix()) : name, value.prefixedValue());
            allocateName(bPrefix ? name.withPrefix(previousValue.prefix()) : name, previousValue.prefixedValue());
        }

        private interface Prefixable<T extends Prefixable<T>> {
            boolean canPrefix();

            String[] prefix();

            T prefixedValue();
        }
    }

    private record NamedProperty(
            PropertyValues values,
            Property property,
            boolean prefixed
    ) implements NameAllocator.Prefixable<NamedProperty> {
        @Override
        public boolean canPrefix() {
            return !prefixed;
        }

        @Override
        public String[] prefix() {
            return values.prefix();
        }

        @Override
        public NamedProperty prefixedValue() {
            return new NamedProperty(values, property, true);
        }
    }

    private record Identifier(String[] words) {
        Identifier(String blockIdentifier) {
            this(blockIdentifier.split("_"));
        }

        String constantName() {
            return Arrays.stream(words)
                    .map((word) -> word.toUpperCase(Locale.US))
                    .collect(Collectors.joining("_"));
        }

        String enumName() {
            return Arrays.stream(words).map((word) -> {
                if (word.length() <= 1) return word.toUpperCase(Locale.US);
                final char[] letters = word.toCharArray();
                letters[0] = Character.toUpperCase(letters[0]);
                return String.valueOf(letters);
            }).collect(Collectors.joining());
        }

        Identifier withPrefix(String[] words) {
            final String[] newWords = new String[this.words.length + words.length];
            System.arraycopy(words, 0, newWords, 0, words.length);
            System.arraycopy(this.words, 0, newWords, words.length, this.words.length);
            return new Identifier(newWords);
        }

        int indexOf(String word) {
            for (int i = 0; i < words.length; i++) {
                if (words[i].equals(word)) return i;
            }
            return -1;
        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof Identifier(String[] otherWords))) return false;

            return Arrays.equals(words, otherWords);
        }

        @Override
        public int hashCode() {
            return Arrays.hashCode(words);
        }
    }

    private static final class Properties {
        final Map<List<String>, PropertyValues> properties = new LinkedHashMap<>();

        void registerProperties(Identifier block, JsonObject blockProperties) {
            blockProperties.entrySet().forEach(entry -> {
                final List<String> values = entry.getValue().getAsJsonArray().asList()
                        .stream().map(JsonElement::getAsString).toList();
                properties.computeIfAbsent(values, PropertyValues::new).registerBlock(entry.getKey(), block);
            });
        }

        void cleanEnums() {
            // Modifying while iterating a set is bad, use a list instead.
            final List<@Nullable List<String>> enums = new ArrayList<>(properties.keySet());
            for (int i = 0; i < enums.size(); i++) {
                final PropertyValues mergeSource = properties.get(enums.get(i));
                if (mergeSource == null) continue;
                for (int j = i + 1; j < enums.size(); j++) {
                    final PropertyValues mergeTarget = properties.get(enums.get(j));
                    if (mergeTarget == null) continue;
                    if (mergeTarget.tryMerge(mergeSource)) {
                        properties.remove(mergeSource.values);
                        break;
                    } else if (mergeSource.tryMerge(mergeTarget)) {
                        properties.remove(mergeTarget.values);
                    }
                }
            }
            properties.values().forEach(PropertyValues::trySplit);
        }
    }

    private static class PropertyValues implements NameAllocator.Prefixable<PropertyValues> {
        final List<String> values;
        final Map<String, Property> properties = new LinkedHashMap<>();
        boolean prefixIdentifier = false;
        @Nullable List<PropertyValues> split = null;

        // -1: unknown, 0: boolean, 1: integer, 2: enum
        private int type = -1;
        private String @Nullable [] prefix = null;

        private PropertyValues(List<String> values) {
            this.values = values;
        }

        private void registerBlock(String property, Identifier block) {
            properties.computeIfAbsent(property, Property::new).registerBlock(block);
        }

        int type() {
            if (type >= 0) return type;
            if (values.getFirst().equals("true")) {
                if (!values.get(1).equals("false")) {
                    throw new RuntimeException("Partial boolean found! properties: " +
                            properties.keySet().stream().toList());
                }
                type = 0; // boolean property
            } else if (values.stream().anyMatch(value -> value.charAt(0) >= '0' && value.charAt(0) <= '9')) {
                // java doesn't allow identifiers to start with numbers
                try {
                    int currentValue = Integer.parseInt(values.getFirst());
                    for (final Iterator<String> iterator = values.listIterator(1); iterator.hasNext(); ) {
                        final int nextValue = Integer.parseInt(iterator.next());
                        if (++currentValue != nextValue) {
                            throw new RuntimeException("non-continuous integer found! properties: " +
                                    properties.keySet().stream().toList());
                        }
                    }
                } catch (NumberFormatException _) {
                    throw new RuntimeException("Partial integer found! properties: " +
                            properties.keySet().stream().toList());
                }
                type = 1; // integer property
            } else {
                type = 2; // enum property
            }

            return type;
        }

        void trySplit() {
            final Map<String, PropertyValues> suffixWordSorted = new LinkedHashMap<>();
            for (final Property property : properties.values()) {
                final Map<String, List<Identifier>> split = property.trySplit();
                if (split == null) continue;
                split.forEach((suffix, blocks) -> {
                    final PropertyValues splitValues = suffixWordSorted.computeIfAbsent(suffix,
                            _ -> new PropertyValues(values));
                    blocks.forEach(block -> splitValues.registerBlock(property.name, block));
                });
            }
            if (suffixWordSorted.isEmpty()) return;
            // Don't make a bazillion enums/property constants.
            if (suffixWordSorted.size() > 4) {
                suffixWordSorted.values().stream()
                        .flatMap(propertyValues -> propertyValues.properties.values().stream())
                        .forEach(property -> property.blocks.forEach(
                                block -> registerBlock(property.name, block)));
                return;
            }
            split = suffixWordSorted.values().stream().toList();
        }

        boolean tryMerge(PropertyValues other) {
            if (other.values.size() >= this.values.size()) return false;
            if (other.properties.keySet().stream().noneMatch(properties::containsKey)) return false;
            // the lists are fairly small
            //noinspection SlowListContainsAll
            if (!this.values.containsAll(other.values)) return false;
            other.properties.forEach((propertyName, otherProperty) -> {
                final Property property = properties.computeIfAbsent(propertyName, Property::new);
                property.registerBlocks(otherProperty.blocks);
            });
            return true;
        }

        Identifier getIdentifier() {
            final String enumPropertiesCombinedName;
            if (properties.size() == 1) {
                enumPropertiesCombinedName = properties.keySet().iterator().next();
            } else {
                enumPropertiesCombinedName = MULTI_PROPERTY_ENUM_NAMES.get(properties.keySet());
                if (enumPropertiesCombinedName == null) {
                    throw new RuntimeException("please add a combined name for the properties " + properties.keySet());
                }
            }
            final Identifier result = removeMatchingPart(getCommonPart(
                    properties.values().stream().map(Property::commonPart).toList()),
                    enumPropertiesCombinedName);
            if (prefixIdentifier) return result.withPrefix(prefix());
            return result;
        }

        @Override
        public boolean canPrefix() {
            return !prefixIdentifier;
        }

        public String[] prefix() {
            if (prefix != null) return prefix;
            return prefix = switch (type()) {
                case 0 -> new String[]{"boolean"};
                case 1 -> new String[]{"int"};
                default -> {
                    if (values.size() > 2 || values.stream().anyMatch(value -> value.contains("_"))) {
                        yield values.stream()
                                .map((word) -> String.valueOf(word.charAt(0)))
                                .toList().toArray(new String[0]);
                    } else {
                        yield values.toArray(new String[0]);
                    }
                }
            };
        }

        @Override
        public PropertyValues prefixedValue() {
            prefixIdentifier = true;
            return this;
        }
    }

    private static class Property {
        final String name;
        List<Identifier> blocks = new ArrayList<>();

        @Nullable
        private Identifier commonPart;
        private Map<String, List<Identifier>> suffixWordSorted = new LinkedHashMap<>(2);


        Property(String name) {
            this.name = name;
        }

        void registerBlock(Identifier block) {
            blocks.add(block);
            commonPart = null;
            suffixWordSorted.computeIfAbsent(block.words[block.words.length - 1],
                    (_) -> new ArrayList<>()).add(block);
        }

        void registerBlocks(Collection<Identifier> blocks) {
            for (final Identifier block : blocks) registerBlock(block);
        }

        @Nullable
        Map<String, List<Identifier>> trySplit() {
            if (commonPart().words.length > 0) return null;
            if (suffixWordSorted.size() <= 1 || suffixWordSorted.size() > 4) return null;

            for (final var entry : suffixWordSorted.entrySet()) {
                final int groupSizeRatio = blocks.size() / (blocks.size() - entry.getValue().size());
                // split other blocks if this group is overwhelming for this property
                if (groupSizeRatio > 4) {
                    final Map<String, List<Identifier>> suffixWordSorted = this.suffixWordSorted;
                    suffixWordSorted.remove(entry.getKey());

                    // update caches
                    commonPart = null;
                    blocks = entry.getValue();
                    this.suffixWordSorted = new HashMap<>();
                    this.suffixWordSorted.put(entry.getKey(), entry.getValue());

                    return suffixWordSorted;
                }
            }
            return null;
        }

        Identifier getIdentifier() {
            return removeMatchingPart(commonPart(), name);
        }

        private Identifier commonPart() {
            if (commonPart != null) return commonPart;
            return commonPart = getCommonPart(blocks);
        }
    }

    private static Identifier removeMatchingPart(Identifier commonPart, String property) {
        if (commonPart.words.length == 0) return new Identifier(property);

        final String[] propertyWords = property.split("_");
        for (final String commonWord : commonPart.words) {
            for (final String propertyWord : propertyWords) {
                if (commonWord.equals(propertyWord)) {
                    return new Identifier(propertyWords);
                }
            }
        }
        return new Identifier(propertyWords).withPrefix(commonPart.words);
    }

    private static Identifier getCommonPart(List<Identifier> blocks) {
        if (blocks.isEmpty()) return new Identifier(new String[0]);
        Identifier result = new Identifier(new String[0]);
        final Identifier first = blocks.getFirst();
        for (int i = 0; i < first.words.length; i++) {
            final String startWord = first.words[i];
            int maxLength = first.words.length - i;
            for (int j = 1; j < blocks.size(); j++) {
                final Identifier other = blocks.get(j);
                final int wordIdx = other.indexOf(startWord);
                if (wordIdx == -1) {
                    maxLength = 0;
                    break;
                }
                for (int k = 1; k < maxLength; k++) {
                    if (wordIdx + k >= other.words.length) {
                        maxLength = k;
                        break;
                    }
                    if (!other.words[wordIdx + k].equals(first.words[i + k])) {
                        maxLength = k;
                        break;
                    }
                }
            }
            if (result.words.length > maxLength || maxLength == 0) continue;
            result = new Identifier(Arrays.copyOfRange(first.words, i, i + maxLength));
        }
        return result;
    }
}
