package net.minestom.codegen.sounds;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.squareup.javapoet.*;
import net.minestom.codegen.MinestomCodeGenerator;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;
import java.util.stream.StreamSupport;

public class BlockSoundTypesGenerator extends MinestomCodeGenerator {
    private static final Logger LOGGER = LoggerFactory.getLogger(BlockSoundTypesGenerator.class);

    private final String packageName;
    private final String interfaceName;
    private final String classImplName;
    private final InputStream entriesFile;
    private final File outputFolder;

    public BlockSoundTypesGenerator(@NotNull String packageName, @NotNull String interfaceName, @NotNull String classImplName, @Nullable InputStream entriesFile, @NotNull File outputFolder
    ) {
        this.packageName = packageName;
        this.interfaceName = interfaceName;
        this.classImplName = classImplName;
        this.entriesFile = entriesFile;
        this.outputFolder = outputFolder;
    }


    @Override
    public void generate() {
        if (entriesFile == null) {
            LOGGER.error("Failed to find entries file.");
            LOGGER.error("Stopped code generation for {}.", interfaceName);
            return;
        }
        if (!outputFolder.exists() && !outputFolder.mkdirs()) {
            LOGGER.error("Output folder for code generation does not exist and could not be created.");
            return;
        }

        JsonArray entryList = GSON.fromJson(new InputStreamReader(entriesFile), JsonArray.class);

        ClassName soundEventCN = ClassName.get("net.minestom.server.sound", "SoundEvent");
        ClassName blockSoundEventCN = ClassName.get("net.minestom.server.sound", "BlockSoundType");
        ClassName mapCN = ClassName.get("java.util", "HashMap");

        // INTERFACE

        ClassName interfaceCN = ClassName.get(packageName, interfaceName);
        TypeSpec.Builder interfaceClass = TypeSpec.interfaceBuilder(interfaceCN)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName());

        interfaceClass.addField(FieldSpec.builder(ParameterizedTypeName.get(mapCN, TypeName.get(java.lang.String.class), blockSoundEventCN), "SOUND_TYPE_INDEX", Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL).initializer("new HashMap<>()").build());

        interfaceClass.addMethod(
                MethodSpec.methodBuilder("getBlockSoundType")
                        .addParameter(ParameterSpec.builder(String.class, "soundTypeName").addAnnotation(NotNull.class).build())
                        .addStatement("return BlockSoundTypes.SOUND_TYPE_INDEX.get(soundTypeName.toLowerCase())")
                        .returns(blockSoundEventCN)
                        .addAnnotation(Nullable.class)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                        .build()
        );

        // RECORD

        ClassName recordCN = ClassName.get(packageName, classImplName);
        // This isn't loaded dynamically from a registry, just a set of static objects, so we can use a record here
        TypeSpec.Builder dataClass = TypeSpec.classBuilder(recordCN)
                .addJavadoc("AUTOGENERATED by " + getClass().getSimpleName())
                .addJavadoc("TODO: Convert to an autogenerated record when possible.");

        dataClass.addSuperinterface(blockSoundEventCN);

        dataClass.addFields(
                List.of(
                        FieldSpec.builder(float.class, "volume", Modifier.PRIVATE, Modifier.FINAL).build(),
                        FieldSpec.builder(float.class, "pitch", Modifier.PRIVATE, Modifier.FINAL).build(),
                        FieldSpec.builder(soundEventCN, "breakSound", Modifier.PRIVATE, Modifier.FINAL).build(),
                        FieldSpec.builder(soundEventCN, "hitSound", Modifier.PRIVATE, Modifier.FINAL).build(),
                        FieldSpec.builder(soundEventCN, "fallSound", Modifier.PRIVATE, Modifier.FINAL).build(),
                        FieldSpec.builder(soundEventCN, "placeSound", Modifier.PRIVATE, Modifier.FINAL).build(),
                        FieldSpec.builder(soundEventCN, "stepSound", Modifier.PRIVATE, Modifier.FINAL).build()
                )
        );

        dataClass.addMethod(
                MethodSpec.constructorBuilder()
                        .addParameter(ParameterSpec.builder(String.class, "soundTypeName").addAnnotation(NotNull.class).build())
                        .addParameter(ParameterSpec.builder(float.class, "volume").build())
                        .addParameter(ParameterSpec.builder(float.class, "pitch").build())
                        .addParameter(ParameterSpec.builder(soundEventCN, "breakSound").addAnnotation(NotNull.class).build())
                        .addParameter(ParameterSpec.builder(soundEventCN, "hitSound").addAnnotation(NotNull.class).build())
                        .addParameter(ParameterSpec.builder(soundEventCN, "fallSound").addAnnotation(NotNull.class).build())
                        .addParameter(ParameterSpec.builder(soundEventCN, "placeSound").addAnnotation(NotNull.class).build())
                        .addParameter(ParameterSpec.builder(soundEventCN, "stepSound").addAnnotation(NotNull.class).build())
                        .addStatement("this.volume = volume")
                        .addStatement("this.pitch = pitch")
                        .addStatement("this.breakSound = breakSound")
                        .addStatement("this.hitSound = hitSound")
                        .addStatement("this.fallSound = fallSound")
                        .addStatement("this.placeSound = placeSound")
                        .addStatement("this.stepSound = stepSound")
                        .addStatement("BlockSoundTypes.SOUND_TYPE_INDEX.put(soundTypeName.toLowerCase(), this)")
                        .build()
        );

        dataClass.addMethods(
                List.of(
                        MethodSpec.methodBuilder("volume").returns(float.class).addStatement("return this.volume").addAnnotation(Override.class).addModifiers(Modifier.PUBLIC).build(),
                        MethodSpec.methodBuilder("pitch").returns(float.class).addStatement("return this.pitch").addAnnotation(Override.class).addModifiers(Modifier.PUBLIC).build(),
                        MethodSpec.methodBuilder("breakSound").returns(soundEventCN).addStatement("return this.breakSound").addAnnotation(Override.class).addAnnotation(NotNull.class).addModifiers(Modifier.PUBLIC).build(),
                        MethodSpec.methodBuilder("hitSound").returns(soundEventCN).addStatement("return this.hitSound").addAnnotation(Override.class).addAnnotation(NotNull.class).addModifiers(Modifier.PUBLIC).build(),
                        MethodSpec.methodBuilder("fallSound").returns(soundEventCN).addStatement("return this.fallSound").addAnnotation(Override.class).addAnnotation(NotNull.class).addModifiers(Modifier.PUBLIC).build(),
                        MethodSpec.methodBuilder("placeSound").returns(soundEventCN).addStatement("return this.placeSound").addAnnotation(Override.class).addAnnotation(NotNull.class).addModifiers(Modifier.PUBLIC).build(),
                        MethodSpec.methodBuilder("stepSound").returns(soundEventCN).addStatement("return this.stepSound").addAnnotation(Override.class).addAnnotation(NotNull.class).addModifiers(Modifier.PUBLIC).build()
                )
        );

        for (JsonObject jsonObject : StreamSupport.stream(entryList.spliterator(), true).map(JsonElement::getAsJsonObject).toList()) {
            String typeName = jsonObject.get("name").getAsString();
            float volume = jsonObject.get("volume").getAsFloat();
            float pitch = jsonObject.get("pitch").getAsFloat();
            String breakSound = jsonObject.get("breakSound").getAsString();
            String hitSound = jsonObject.get("hitSound").getAsString();
            String fallSound = jsonObject.get("fallSound").getAsString();
            String placeSound = jsonObject.get("placeSound").getAsString();
            String stepSound = jsonObject.get("stepSound").getAsString();
            interfaceClass.addField(FieldSpec.builder(blockSoundEventCN, typeName.toUpperCase(), Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer("new BlockSoundTypeImpl($S, $Lf, $Lf, BuiltinSoundEvent.get($S), BuiltinSoundEvent.get($S), BuiltinSoundEvent.get($S), BuiltinSoundEvent.get($S), BuiltinSoundEvent.get($S))", typeName, volume, pitch, breakSound, hitSound, fallSound, placeSound, stepSound).build());
        }

        // Write files to outputFolder
        writeFiles(
                List.of(
                        JavaFile.builder(packageName, interfaceClass.build())
                                .indent("    ")
                                .skipJavaLangImports(true)
                                .build(),
                        JavaFile.builder(packageName, dataClass.build())
                                .indent("    ")
                                .skipJavaLangImports(true)
                                .build()
                ),
                outputFolder
        );
    }
}
