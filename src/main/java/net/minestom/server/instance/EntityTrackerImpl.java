package net.minestom.server.instance;

import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import net.minestom.server.ServerFlag;
import net.minestom.server.Viewable;
import net.minestom.server.coordinate.ChunkRange;
import net.minestom.server.coordinate.CoordConversion;
import net.minestom.server.coordinate.Point;
import net.minestom.server.coordinate.Vec;
import net.minestom.server.entity.Entity;
import net.minestom.server.entity.Player;
import net.minestom.server.utils.validate.Check;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.Unmodifiable;
import org.jetbrains.annotations.UnmodifiableView;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import space.vectrix.flare.fastutil.Int2ObjectSyncMap;
import space.vectrix.flare.fastutil.Long2ObjectSyncMap;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.function.Function;

import static net.minestom.server.instance.Chunk.CHUNK_SIZE_X;
import static net.minestom.server.instance.Chunk.CHUNK_SIZE_Z;

final class EntityTrackerImpl implements EntityTracker {
    private static final Logger LOGGER = LoggerFactory.getLogger(EntityTrackerImpl.class);

    static final AtomicInteger TARGET_COUNTER = new AtomicInteger();

    // Store all data associated to a Target
    // The array index is the Target enum ordinal
    final TargetEntry<Entity>[] targetEntries = EntityTracker.Target.TARGETS.stream().map((Function<Target<?>, TargetEntry>) TargetEntry::new).toArray(TargetEntry[]::new);

    private final Int2ObjectSyncMap<EntityTrackerEntry> entriesByEntityId = Int2ObjectSyncMap.hashmap();
    private final Map<UUID, EntityTrackerEntry> entriesByEntityUuid = new ConcurrentHashMap<>();

    @Override
    public <T extends Entity> void register(Entity entity, Point point,
                                            Target<T> target, @Nullable Update<T> update) {
        EntityTrackerEntry newEntry = new EntityTrackerEntry(entity, point);

        EntityTrackerEntry prevEntryWithId = entriesByEntityId.putIfAbsent(entity.getEntityId(), newEntry);
        Check.isTrue(prevEntryWithId == null, "There is already an entity registered with id {0}", entity.getEntityId());
        EntityTrackerEntry prevEntryWithUuid = entriesByEntityUuid.putIfAbsent(entity.getUuid(), newEntry);
        Check.isTrue(prevEntryWithUuid == null, "There is already an entity registered with uuid {0}", entity.getUuid());

        final long index = CoordConversion.chunkIndex(point);
        for (TargetEntry<Entity> targetEntry : targetEntries) {
            if (targetEntry.target.type().isInstance(entity)) {
                targetEntry.entities.add(entity);
                targetEntry.addToChunk(index, entity);
            }
        }
        if (update != null) {
            update.referenceUpdate(point, this);
            nearbyEntitiesByChunkRange(point, ServerFlag.ENTITY_VIEW_DISTANCE, target, newEntity -> {
                if (newEntity == entity) return;
                update.add(newEntity);
            });
        }
    }

    @Override
    public <T extends Entity> void unregister(Entity entity,
                                              Target<T> target, @Nullable Update<T> update) {
        EntityTrackerEntry entry = entriesByEntityId.remove(entity.getEntityId());
        entriesByEntityUuid.remove(entity.getUuid());
        final Point point = entry == null ? null : entry.getLastPosition();
        if (point == null) return;

        final long index = CoordConversion.chunkIndex(point);
        for (TargetEntry<Entity> targetEntry : targetEntries) {
            if (targetEntry.target.type().isInstance(entity)) {
                targetEntry.entities.remove(entity);
                targetEntry.removeFromChunk(index, entity);
            }
        }
        if (update != null) {
            update.referenceUpdate(point, null);
            nearbyEntitiesByChunkRange(point, ServerFlag.ENTITY_VIEW_DISTANCE, target, newEntity -> {
                if (newEntity == entity) return;
                update.remove(newEntity);
            });
        }
    }

    @Override
    public @Nullable Entity getEntityById(int id) {
        EntityTrackerEntry entry = entriesByEntityId.get(id);
        return entry == null ? null : entry.getEntity();
    }

    @Override
    public @Nullable Entity getEntityByUuid(UUID uuid) {
        EntityTrackerEntry entry = entriesByEntityUuid.get(uuid);
        return entry == null ? null : entry.getEntity();
    }

    @Override
    public <T extends Entity> void move(Entity entity, Point newPoint,
                                        Target<T> target, @Nullable Update<T> update) {
        EntityTrackerEntry entry = entriesByEntityId.get(entity.getEntityId());
        if (entry == null) {
            LOGGER.warn("Attempted to move unregistered entity {} in the entity tracker", entity.getEntityId());
            return;
        }
        Point oldPoint = entry.getLastPosition();
        entry.setLastPosition(newPoint);
        if (oldPoint == null || oldPoint.sameChunk(newPoint)) return;
        final long oldIndex = CoordConversion.chunkIndex(oldPoint);
        final long newIndex = CoordConversion.chunkIndex(newPoint);
        for (TargetEntry<Entity> targetEntry : targetEntries) {
            if (targetEntry.target.type().isInstance(entity)) {
                targetEntry.addToChunk(newIndex, entity);
                targetEntry.removeFromChunk(oldIndex, entity);
            }
        }
        if (update != null) {
            difference(oldPoint, newPoint, target, new Update<>() {
                @Override
                public void add(T added) {
                    if (entity != added) update.add(added);
                }

                @Override
                public void remove(T removed) {
                    if (entity != removed) update.remove(removed);
                }
            });
            update.referenceUpdate(newPoint, this);
        }
    }

    @Override
    public @Unmodifiable <T extends Entity> Collection<T> chunkEntities(int chunkX, int chunkZ, Target<T> target) {
        //noinspection unchecked
        final TargetEntry<T> entry = (TargetEntry<T>) targetEntries[target.ordinal()];
        List<T> chunkEntities = entry.chunkEntities(CoordConversion.chunkIndex(chunkX, chunkZ));
        if (chunkEntities == null) return List.of();
        return Collections.unmodifiableList(chunkEntities);
    }

    @Override
    public <T extends Entity> void nearbyEntitiesByChunkRange(Point point, int chunkRange, Target<T> target, Consumer<T> query) {
        final Long2ObjectSyncMap<List<Entity>> entities = targetEntries[target.ordinal()].chunkEntities;
        if (chunkRange == 0) {
            // Single chunk
            final var chunkEntities = (List<T>) entities.get(CoordConversion.chunkIndex(point));
            if (chunkEntities != null && !chunkEntities.isEmpty()) {
                chunkEntities.forEach(query);
            }
        } else {
            // Multiple chunks
            ChunkRange.chunksInRange(point, chunkRange, (chunkX, chunkZ) -> {
                final var chunkEntities = (List<T>) entities.get(CoordConversion.chunkIndex(chunkX, chunkZ));
                if (chunkEntities == null || chunkEntities.isEmpty()) return;
                chunkEntities.forEach(query);
            });
        }
    }

    @Override
    public <T extends Entity> void nearbyEntities(Point point, double range, Target<T> target, Consumer<T> query) {
        final Long2ObjectSyncMap<List<Entity>> entities = targetEntries[target.ordinal()].chunkEntities;
        final int minChunkX = CoordConversion.globalToChunk(point.x() - range);
        final int minChunkZ = CoordConversion.globalToChunk(point.z() - range);
        final int maxChunkX = CoordConversion.globalToChunk(point.x() + range);
        final int maxChunkZ = CoordConversion.globalToChunk(point.z() + range);
        final double squaredRange = range * range;
        if (minChunkX == maxChunkX && minChunkZ == maxChunkZ) {
            // Single chunk
            final var chunkEntities = (List<T>) entities.get(CoordConversion.chunkIndex(point));
            if (chunkEntities != null && !chunkEntities.isEmpty()) {
                chunkEntities.forEach(entity -> {
                    final Point position = entriesByEntityId.get(entity.getEntityId()).getLastPosition();
                    if (point.distanceSquared(position) <= squaredRange) query.accept(entity);
                });
            }
        } else {
            // Multiple chunks
            final int chunkRange = (int) (range / Chunk.CHUNK_SECTION_SIZE) + 1;
            ChunkRange.chunksInRange(point, chunkRange, (chunkX, chunkZ) -> {
                final var chunkEntities = (List<T>) entities.get(CoordConversion.chunkIndex(chunkX, chunkZ));
                if (chunkEntities == null || chunkEntities.isEmpty()) return;
                chunkEntities.forEach(entity -> {
                    final Point position = entriesByEntityId.get(entity.getEntityId()).getLastPosition();
                    if (point.distanceSquared(position) <= squaredRange) {
                        query.accept(entity);
                    }
                });
            });
        }
    }

    @Override
    public @UnmodifiableView <T extends Entity> Set<T> entities(Target<T> target) {
        //noinspection unchecked
        return (Set<T>) targetEntries[target.ordinal()].entitiesView;
    }

    @Override
    public Viewable viewable(List<SharedInstance> sharedInstances, int chunkX, int chunkZ) {
        var entry = targetEntries[Target.PLAYERS.ordinal()];
        return entry.viewable(this, sharedInstances, chunkX, chunkZ);
    }

    @Override
    public void unregisterViewable(Viewable viewable) {
        if (!(viewable instanceof ChunkView chunkView)) {
            throw new IllegalArgumentException("viewable is not a ChunkView");
        }
        var entry = targetEntries[Target.PLAYERS.ordinal()];
        entry.unregisterViewable(chunkView);
    }

    private static final class EntityTrackerEntry {
        private final Entity entity;
        private @Nullable Point lastPosition;

        private EntityTrackerEntry(Entity entity, @Nullable Point lastPosition) {
            this.entity = entity;
            this.lastPosition = lastPosition;
        }

        public Entity getEntity() {
            return entity;
        }

        @Nullable
        public Point getLastPosition() {
            return lastPosition;
        }

        public void setLastPosition(Point lastPosition) {
            this.lastPosition = lastPosition;
        }
    }

    private <T extends Entity> void difference(Point oldPoint, Point newPoint,
                                               Target<T> target, Update<T> update) {
        final TargetEntry<Entity> entry = targetEntries[target.ordinal()];
        ChunkRange.chunksInRangeDiffering(newPoint.chunkX(), newPoint.chunkZ(), oldPoint.chunkX(), oldPoint.chunkZ(),
                ServerFlag.ENTITY_VIEW_DISTANCE, (chunkX, chunkZ) -> {
                    // Add
                    final List<Entity> entities = entry.chunkEntities.get(CoordConversion.chunkIndex(chunkX, chunkZ));
                    if (entities == null || entities.isEmpty()) return;
                    for (Entity entity : entities) update.add((T) entity);
                }, (chunkX, chunkZ) -> {
                    // Remove
                    final List<Entity> entities = entry.chunkEntities.get(CoordConversion.chunkIndex(chunkX, chunkZ));
                    if (entities == null || entities.isEmpty()) return;
                    for (Entity entity : entities) update.remove((T) entity);
                });
    }

    record ChunkViewKey(List<SharedInstance> sharedInstances, int chunkX, int chunkZ) {
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (!(obj instanceof ChunkViewKey key)) return false;
            return sharedInstances == key.sharedInstances &&
                    chunkX == key.chunkX &&
                    chunkZ == key.chunkZ;
        }
    }

    static final class TargetEntry<T extends Entity> {
        private final EntityTracker.Target<T> target;
        private final Set<T> entities = ConcurrentHashMap.newKeySet(); // Thread-safe since exposed
        private final Set<T> entitiesView = Collections.unmodifiableSet(entities);
        // Chunk index -> entities inside it
        final Long2ObjectSyncMap<@Nullable List<T>> chunkEntities = Long2ObjectSyncMap.hashmap();
        // Chunk viewers (Only Players)
        final Map<ChunkViewKey, ChunkView> viewers;

        TargetEntry(Target<T> target) {
            this.target = target;
            this.viewers = target == Target.PLAYERS ? new ConcurrentHashMap<>() : Map.of();
        }

        @Nullable
        List<T> chunkEntities(long index) {
            return chunkEntities.get(index);
        }

        void addToChunk(long index, T entity) {
            chunkEntities.computeIfAbsent(index, _ -> new CopyOnWriteArrayList<>()).add(entity);
        }

        void removeFromChunk(long index, T entity) {
            List<T> entities = chunkEntities.get(index);
            if (entities == null) return;
            entities.remove(entity);
            if (entities.isEmpty()) chunkEntities.remove(index);
        }

        Viewable viewable(EntityTracker tracker, List<SharedInstance> sharedInstances, int chunkX, int chunkZ) {
            return viewers.computeIfAbsent(new ChunkViewKey(sharedInstances, chunkX, chunkZ), it -> new ChunkView(tracker, it));
        }

        void unregisterViewable(ChunkView viewable) {
            viewers.remove(viewable.key, viewable);
            // While this isn't thread safe, it should help people from reusing chunks.
            viewable.lastReferenceCount = Integer.MIN_VALUE;
        }
    }

    private static final class ChunkView extends AbstractSet<Player> implements Viewable {
        private final EntityTracker tracker;
        private final ChunkViewKey key;
        private final Point point;
        private int lastReferenceCount;

        private ChunkView(EntityTracker tracker, ChunkViewKey key) {
            this.tracker = tracker;
            this.key = key;
            this.point = new Vec(key.chunkX, key.chunkZ).mul(CHUNK_SIZE_X, 0, CHUNK_SIZE_Z);
            super();
        }

        @Override
        public boolean addViewer(Player player) {
            throw new UnsupportedOperationException("Chunk does not support manual viewers");
        }

        @Override
        public boolean removeViewer(Player player) {
            throw new UnsupportedOperationException("Chunk does not support manual viewers");
        }

        @Override
        public Set<Player> getViewers() {
            return this;
        }

        private Collection<Player> references() {
            assertRegistered();
            Int2ObjectOpenHashMap<Player> entityMap = new Int2ObjectOpenHashMap<>(lastReferenceCount);
            collectPlayers(this.tracker, entityMap);
            if (!key.sharedInstances.isEmpty()) {
                for (SharedInstance instance : key.sharedInstances) {
                    collectPlayers(instance.getEntityTracker(), entityMap);
                }
            }
            this.lastReferenceCount = entityMap.size();
            return entityMap.values();
        }

        private void collectPlayers(EntityTracker tracker, Int2ObjectOpenHashMap<? super Player> map) {
            tracker.nearbyEntitiesByChunkRange(point, ServerFlag.CHUNK_VIEW_DISTANCE,
                    EntityTracker.Target.PLAYERS, (player) -> map.putIfAbsent(player.getEntityId(), player));
        }

        // Implement the set here, no reason to have another object allocated for this for N chunks.
        @Override
        public Iterator<Player> iterator() {
            return references().iterator();
        }

        @Override
        public int size() {
            return references().size();
        }

        @Override
        public void forEach(Consumer<? super Player> action) {
            references().forEach(action);
        }

        private void assertRegistered() {
            if (lastReferenceCount == Integer.MIN_VALUE)
                throw new IllegalStateException("Cannot gather references from an unregistered chunk: (%d, %d)".formatted(key.chunkX, key.chunkZ));
        }
    }
}
